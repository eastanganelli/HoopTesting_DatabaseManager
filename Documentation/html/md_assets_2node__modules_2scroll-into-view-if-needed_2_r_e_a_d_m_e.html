<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DatabaseManager: README</title>
<link rel="icon" href="icon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DatabaseManager<span id="projectnumber">&#160;1.0.5</span>
   </div>
   <div id="projectbrief">Database Manager Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_assets_2node__modules_2scroll-into-view-if-needed_2_r_e_a_d_m_e.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">README</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://npm-stat.com/charts.html?package=scroll-into-view-if-needed"><img src="https://img.shields.io/npm/dm/scroll-into-view-if-needed.svg?style=flat-square" alt="npm stat" style="pointer-events: none;" class="inline"/></a> <a href="https://www.npmjs.com/package/scroll-into-view-if-needed"><img src="https://img.shields.io/npm/v/scroll-into-view-if-needed.svg?style=flat-square" alt="npm version" style="pointer-events: none;" class="inline"/></a> <a href="https://unpkg.com/scroll-into-view-if-needed/dist/"><img src="https://img.shields.io/bundlephobia/minzip/scroll-into-view-if-needed?label=gzip%20size&amp;style=flat-square" alt="gzip size" class="inline"/></a> <a href="https://unpkg.com/scroll-into-view-if-needed/dist/"><img src="https://img.shields.io/bundlephobia/min/scroll-into-view-if-needed?label=size&amp;style=flat-square" alt="size" class="inline"/></a> <a href="https://github.com/semantic-release/semantic-release"><img src="https://img.shields.io/badge/%20%20%F0%9F%93%A6%F0%9F%9A%80-semantic--release-e10079.svg?style=flat-square" alt="semantic-release" style="pointer-events: none;" class="inline"/></a> <a href="https://www.browserstack.com/automate/public-build/ejZ6OUtTaS9rZFFOYzlkeHlwTzMwSWxpR0FzWFcwOW5TS3ROTmlSdXMrVT0tLVhrVk9La2lCb1o4Y05mcmNXVnAvdkE9PQ==--d17668b8aba5091e4ef3a58927b8209e50b0a788"><img src="https://www.browserstack.com/automate/badge.svg?style=flat-square&amp;badge_key=ejZ6OUtTaS9rZFFOYzlkeHlwTzMwSWxpR0FzWFcwOW5TS3ROTmlSdXMrVT0tLVhrVk9La2lCb1o4Y05mcmNXVnAvdkE9PQ==--d17668b8aba5091e4ef3a58927b8209e50b0a788" alt="BrowserStack Status" style="pointer-events: none;" class="inline"/></a></p>
<p><img src="https://user-images.githubusercontent.com/81981/39476436-34a4f3ae-4d5c-11e8-9d1c-7fa2fa6288a0.png" alt="scroll-into-view-if-needed" class="inline"/></p>
<p>This used to be a <a href="https://ponyfill.com">ponyfill</a> for <code>Element.scrollIntoViewIfNeeded</code>. Since then the CSS working group have decided to implement its features in <code>Element.scrollIntoView</code> as the option <code>scrollMode: "if-needed"</code>. Thus this library got rewritten to implement that spec instead of the soon to be deprecated one.</p>
<ul>
<li>Demo</li>
<li>Install</li>
<li>Usage<ul>
<li>Ponyfill smooth scrolling<ul>
<li>Load time</li>
<li>Consistency</li>
<li>Quality</li>
</ul>
</li>
</ul>
</li>
<li>API<ul>
<li>scrollIntoView(target, \[options\])</li>
<li><a class="el" href="md_assets_2node__modules_2node-forge_2_r_e_a_d_m_e.html#options">options</a><ul>
<li>behavior<ul>
<li>`'auto'`</li>
<li>`'smooth'`</li>
<li>`Function`</li>
</ul>
</li>
<li>block</li>
<li>inline</li>
<li>scrollMode</li>
<li>boundary</li>
<li>skipOverflowHiddenElements</li>
</ul>
</li>
</ul>
</li>
<li>TypeScript support</li>
<li>Breaking API changes from v1<ul>
<li>v1</li>
<li>v2</li>
<li>centerIfNeeded<ul>
<li>v1</li>
<li>v2</li>
</ul>
</li>
<li>duration<ul>
<li>v1</li>
<li>v2</li>
</ul>
</li>
<li>easing</li>
<li>handleScroll</li>
<li>offset</li>
<li>scrollIntoViewIfNeeded(target, \[centerIfNeeded\], \[animateOptions\], \[finalElement\], \[offsetOptions\])</li>
</ul>
</li>
<li>Related packages</li>
<li>Who's using this</li>
<li>Sponsors</li>
</ul>
<h1><a class="anchor" id="autotoc_md8053"></a>
<a href="https://scroll-into-view.dev">Demo</a></h1>
<h1><a class="anchor" id="autotoc_md8054"></a>
Install</h1>
<div class="fragment"><div class="line">npm i scroll-into-view-if-needed</div>
</div><!-- fragment --><p>You can also use it from a CDN:</p>
<div class="fragment"><div class="line">const { default: scrollIntoView } = await import(</div>
<div class="line">  &#39;https://esm.sh/scroll-into-view-if-needed&#39;</div>
<div class="line">)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8055"></a>
Usage</h1>
<div class="fragment"><div class="line">import scrollIntoView from &#39;scroll-into-view-if-needed&#39;</div>
<div class="line"> </div>
<div class="line">const node = document.getElementById(&#39;hero&#39;)</div>
<div class="line"> </div>
<div class="line">// similar behavior as Element.scrollIntoView({block: &quot;nearest&quot;, inline: &quot;nearest&quot;})</div>
<div class="line">// only that it is a no-op if `node` is already visible</div>
<div class="line">// see: https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView</div>
<div class="line">// same behavior as Element.scrollIntoViewIfNeeded()</div>
<div class="line">// see: https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoViewIfNeeded</div>
<div class="line">scrollIntoView(node, {</div>
<div class="line">  scrollMode: &#39;if-needed&#39;,</div>
<div class="line">  block: &#39;nearest&#39;,</div>
<div class="line">  inline: &#39;nearest&#39;,</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">// same behavior as Element.scrollIntoViewIfNeeded(true) without the &quot;IfNeeded&quot; behavior</div>
<div class="line">// see: https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoViewIfNeeded</div>
<div class="line">scrollIntoView(node, { block: &#39;center&#39;, inline: &#39;center&#39; })</div>
<div class="line">// scrollMode is &quot;always&quot; by default</div>
<div class="line"> </div>
<div class="line">// smooth scroll if the browser supports it and if the element isn&#39;t visible</div>
<div class="line">scrollIntoView(node, { behavior: &#39;smooth&#39;, scrollMode: &#39;if-needed&#39; })</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8056"></a>
Ponyfill smooth scrolling</h2>
<p>What does ponyfilling smooth scrolling mean, and why is it implemented in <a href="https://github.com/scroll-into-view/smooth-scroll-into-view-if-needed"><code>smooth-scroll-into-view-if-needed</code></a> instead? The answer is bundlesize. If this package adds smooth scrolling to browsers that's missing it then the overall bundlesize increases regardless of wether you use this feature or not.</p>
<p>Put it this way:</p>
<div class="fragment"><div class="line">import scrollIntoView from &#39;scroll-into-view-if-needed&#39;</div>
<div class="line">// Even if all you do is this</div>
<div class="line">scrollIntoView(node, { scrollMode: &#39;if-needed&#39; })</div>
<div class="line">// You would end up with the same bundlesize as people who need</div>
<div class="line">// smooth scrolling to work in browsers that don&#39;t support it natively</div>
<div class="line">scrollIntoView(node, { behavior: &#39;smooth&#39;, scrollMode: &#39;if-needed&#39; })</div>
</div><!-- fragment --><p>That's why only native smooth scrolling is supported out of the box. There are two common ways you can smooth scroll browsers that don't support it natively. Below is all three, which one is best for you depends on what is the most important to your use case:: load time, consistency or quality.</p>
<h3><a class="anchor" id="autotoc_md8057"></a>
Load time</h3>
<p>In many scenarios smooth scrolling can be used as a progressive enhancement. If the user is on a browser that don't implement smooth scrolling it'll simply scroll instantly and your bundlesize is only as large as it has to be.</p>
<div class="fragment"><div class="line">import scrollIntoView from &#39;scroll-into-view-if-needed&#39;</div>
<div class="line"> </div>
<div class="line">scrollIntoView(node, { behavior: &#39;smooth&#39; })</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8058"></a>
Consistency</h3>
<p>If a consistent smooth scrolling experience is a priority and you really don't want any surprises between different browsers and enviroments. In other words don't want to be affected by how a vendor might implement native smooth scrolling, then <a href="https://github.com/scroll-into-view/smooth-scroll-into-view-if-needed"><code>smooth-scroll-into-view-if-needed</code></a> is your best option. It ensures the same smooth scrolling experience for every browser.</p>
<div class="fragment"><div class="line">import smoothScrollIntoView from &#39;smooth-scroll-into-view-if-needed&#39;</div>
<div class="line"> </div>
<div class="line">smoothScrollIntoView(node, { behavior: &#39;smooth&#39; })</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8059"></a>
Quality</h3>
<p>If you want to use native smooth scrolling when it's available, and fallback to the smooth scrolling ponyfill:</p>
<div class="fragment"><div class="line">import scrollIntoView from &#39;scroll-into-view-if-needed&#39;</div>
<div class="line">import smoothScrollIntoView from &#39;smooth-scroll-into-view-if-needed&#39;</div>
<div class="line"> </div>
<div class="line">const scrollIntoViewSmoothly =</div>
<div class="line">  &#39;scrollBehavior&#39; in document.documentElement.style</div>
<div class="line">    ? scrollIntoView</div>
<div class="line">    : smoothScrollIntoView</div>
<div class="line"> </div>
<div class="line">scrollIntoViewSmoothly(node, { behavior: &#39;smooth&#39; })</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8060"></a>
API</h1>
<h2><a class="anchor" id="autotoc_md8061"></a>
scrollIntoView(target, [options])</h2>
<blockquote class="doxtable">
<p>&zwj;New API introduced in <code>v1.3.0</code> </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md8062"></a>
options</h2>
<p>Type: <code>Object</code></p>
<h3><a class="anchor" id="autotoc_md8063"></a>
behavior</h3>
<p>Type: &lsquo;'auto&rsquo; | 'smooth' | Function<code>&lt;br&gt; Default:</code>'auto'`</p>
<blockquote class="doxtable">
<p>&zwj;Introduced in <code>v2.1.0</code> </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md8064"></a>
&lsquo;'auto&rsquo;`</h4>
<p>The auto option unlocks a few interesting opportunities. The browser will decide based on user preferences wether it should smooth scroll or not. On top of that you can control/override scrolling behavior through the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior"><code>scroll-behavior</code></a> CSS property.</p>
<p>Some people get <a href="https://css-tricks.com/smooth-scrolling-accessibility/#article-header-id-5">motion sick from animations</a>. You can use CSS to turn off smooth scrolling in those cases to avoid making them dizzy:</p>
<div class="fragment"><div class="line">html,</div>
<div class="line">.scroll-container {</div>
<div class="line">  overflow: scroll;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">html,</div>
<div class="line">.scroll-container {</div>
<div class="line">  scroll-behavior: smooth;</div>
<div class="line">}</div>
<div class="line">@media (prefers-reduced-motion) {</div>
<div class="line">  html,</div>
<div class="line">  .scroll-container {</div>
<div class="line">    scroll-behavior: auto;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h4><a class="anchor" id="autotoc_md8065"></a>
&lsquo;'smooth&rsquo;`</h4>
<p>Using &lsquo;behavior: 'smooth&rsquo;` is the easiest way to smooth scroll an element as it does not require any CSS, just a browser that implements it. More information.</p>
<h4><a class="anchor" id="autotoc_md8066"></a>
<code>Function</code></h4>
<p>When given a function then this library will only calculate what should be scrolled and leave it up to you to perform the actual scrolling.</p>
<p>The callback is given an array over actions. Each action contain a reference to an element that should be scrolled, with its top and left scrolling coordinates. What you return is passed through, allowing you to implement a Promise interface if you want to (check <a href="https://github.com/scroll-into-view/smooth-scroll-into-view-if-needed"><code>smooth-scroll-into-view-if-needed</code></a> to see an example of that).</p>
<div class="fragment"><div class="line">import scrollIntoView from &#39;scroll-into-view-if-needed&#39;</div>
<div class="line">const node = document.getElementById(&#39;hero&#39;)</div>
<div class="line"> </div>
<div class="line">scrollIntoView(node, {</div>
<div class="line">  // Your scroll actions will always be an array, even if there is nothing to scroll</div>
<div class="line">  behavior: (actions) =&gt;</div>
<div class="line">    // list is sorted from innermost (closest parent to your target) to outermost (often the document.body or viewport)</div>
<div class="line">    actions.forEach(({ el, top, left }) =&gt; {</div>
<div class="line">      // implement the scroll anyway you want</div>
<div class="line">      el.scrollTop = top</div>
<div class="line">      el.scrollLeft = left</div>
<div class="line"> </div>
<div class="line">      // If you need the relative scroll coordinates, for things like window.scrollBy style logic or whatever, just do the math</div>
<div class="line">      const offsetTop = el.scrollTop - top</div>
<div class="line">      const offsetLeft = el.scrollLeft - left</div>
<div class="line">    }),</div>
<div class="line">  // all the other options (scrollMode, block, inline) still work, so you don&#39;t need to reimplement them (unless you really really want to)</div>
<div class="line">})</div>
</div><!-- fragment --><p>Check the demo to see an <a href="https://scroll-into-view.dev/#custom-transition">example with popmotion and a spring transition</a>.</p>
<blockquote class="doxtable">
<p>&zwj;If you only need the custom behavior you might be better off by using the compute library directly: <a href="https://github.com/scroll-into-view/compute-scroll-into-view">https://github.com/scroll-into-view/compute-scroll-into-view</a> </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md8067"></a>
<a href="https://scroll-into-view.dev/#scroll-alignment">block</a></h3>
<p>Type: &lsquo;'start&rsquo; | 'center' | 'end' | 'nearest'<code>&lt;br&gt; Default:</code>'center'`</p>
<blockquote class="doxtable">
<p>&zwj;Introduced in <code>v2.1.0</code> </p>
</blockquote>
<p><a href="https://github.com/scroll-into-view/compute-scroll-into-view#block">More info.</a></p>
<h3><a class="anchor" id="autotoc_md8068"></a>
<a href="https://scroll-into-view.dev/#scroll-alignment">inline</a></h3>
<p>Type: &lsquo;'start&rsquo; | 'center' | 'end' | 'nearest'<code>&lt;br&gt; Default:</code>'nearest'`</p>
<blockquote class="doxtable">
<p>&zwj;Introduced in <code>v2.1.0</code> </p>
</blockquote>
<p><a href="https://github.com/scroll-into-view/compute-scroll-into-view#inline">More info.</a></p>
<h3><a class="anchor" id="autotoc_md8069"></a>
<a href="https://scroll-into-view.dev/#scrolling-if-needed">scrollMode</a></h3>
<p>Type: &lsquo;'always&rsquo; | 'if-needed'<code>&lt;br&gt; Default:</code>'always'`</p>
<blockquote class="doxtable">
<p>&zwj;Introduced in <code>v2.1.0</code> </p>
</blockquote>
<p><a href="https://github.com/scroll-into-view/compute-scroll-into-view#scrollmode">More info.</a></p>
<h3><a class="anchor" id="autotoc_md8070"></a>
<a href="https://scroll-into-view.dev/#limit-propagation">boundary</a></h3>
<p>Type: <code>Element | Function</code></p>
<blockquote class="doxtable">
<p>&zwj;<code>Function</code> introduced in <code>v2.1.0</code>, <code>Element</code> introduced in <code>v1.1.0</code> </p>
</blockquote>
<p><a href="https://github.com/scroll-into-view/compute-scroll-into-view#boundary">More info.</a></p>
<h3><a class="anchor" id="autotoc_md8071"></a>
skipOverflowHiddenElements</h3>
<p>Type: <code>Boolean</code><br  />
 Default: <code>false</code></p>
<blockquote class="doxtable">
<p>&zwj;Introduced in <code>v2.2.0</code> </p>
</blockquote>
<p><a href="https://github.com/scroll-into-view/compute-scroll-into-view#skipoverflowhiddenelements">More info.</a></p>
<h1><a class="anchor" id="autotoc_md8072"></a>
TypeScript support</h1>
<p>When the library itself is built on TypeScript there's no excuse for not publishing great library definitions!</p>
<p>This goes beyond just checking if you misspelled &lsquo;behavior: 'smoooth&rsquo;` to the return type of a custom behavior:</p>
<div class="fragment"><div class="line">const scrolling = scrollIntoView(document.body, {</div>
<div class="line">  behavior: actions =&gt; {</div>
<div class="line">    return new Promise(</div>
<div class="line">      ...</div>
<div class="line">    )</div>
<div class="line">  },</div>
<div class="line">})</div>
<div class="line">// TypeScript understands that scrolling is a Promise, you can safely await on it</div>
<div class="line">scrolling.then(() =&gt; console.log(&#39;done scrolling&#39;))</div>
</div><!-- fragment --><p>You can optionally use a generic to ensure that <code>options.behavior</code> is the expected type. It can be useful if the custom behavior is implemented in another module:</p>
<div class="fragment"><div class="line">const customBehavior = actions =&gt; {</div>
<div class="line">    return new Promise(</div>
<div class="line">      ...</div>
<div class="line">    )</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">const scrolling = scrollIntoView&lt;Promise&lt;any&gt;&gt;(document.body, {</div>
<div class="line">  behavior: customBehavior</div>
<div class="line">})</div>
<div class="line">// throws if customBehavior does not return a promise</div>
</div><!-- fragment --><p>The options are available for you if you are wrapping this libary in another abstraction (like a React component):</p>
<div class="fragment"><div class="line">import scrollIntoView, { type Options } from &#39;scroll-into-view-if-needed&#39;</div>
<div class="line"> </div>
<div class="line">interface CustomOptions extends Options {</div>
<div class="line">  useBoundary?: boolean</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">function scrollToTarget(selector, options: Options = {}) {</div>
<div class="line">  const { useBoundary = false, ...scrollOptions } = options</div>
<div class="line">  return scrollIntoView(document.querySelector(selector), scrollOptions)</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8073"></a>
Breaking API changes from v1</h1>
<p>Since v1 ponyfilled Element.scrollIntoViewIfNeeded, while v2 ponyfills Element.scrollIntoView, there are breaking changes from the differences in their APIs.</p>
<p>The biggest difference is that the new behavior follows the spec, so the "if-needed" behavior is <b>not enabled by default:</b></p>
<h3><a class="anchor" id="autotoc_md8074"></a>
v1</h3>
<div class="fragment"><div class="line">import scrollIntoViewIfNeeded from &#39;scroll-into-view-if-needed&#39;</div>
<div class="line"> </div>
<div class="line">// Only scrolls into view if needed, and to the nearest edge</div>
<div class="line">scrollIntoViewIfNeeded(target)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8075"></a>
v2</h3>
<div class="fragment"><div class="line">import scrollIntoView from &#39;scroll-into-view-if-needed&#39;</div>
<div class="line"> </div>
<div class="line">// Must provide these options to behave the same way as v1 default</div>
<div class="line">scrollIntoView(target, { block: &#39;nearest&#39;, scrollMode: &#39;if-needed&#39; })</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8076"></a>
centerIfNeeded</h2>
<p>The old <code>Element.scrollIntoView</code> api only had two settings, align to top or bottom. <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoViewIfNeeded"><code>Element.scrollIntoViewIfNeeded</code></a> had two more, align to the center or nearest edge. The <code>Element.scrollIntoView</code> spec now supports these two modes as &lsquo;block: 'center&rsquo;<code>and</code>block: 'nearest'`. Breaking changes sucks, but on the plus side your code is now more portable and will make this library easier to delete from your codebase on the glorious day browser support is good enough.</p>
<h3><a class="anchor" id="autotoc_md8077"></a>
v1</h3>
<div class="fragment"><div class="line">import scrollIntoViewIfNeeded from &#39;scroll-into-view-if-needed&#39;</div>
<div class="line"> </div>
<div class="line">// v1.3.x and later</div>
<div class="line">scrollIntoViewIfNeeded(target, { centerIfNeeded: true })</div>
<div class="line">scrollIntoViewIfNeeded(target, { centerIfNeeded: false })</div>
<div class="line">// v1.2.x and earlier</div>
<div class="line">scrollIntoViewIfNeeded(target, true)</div>
<div class="line">scrollIntoViewIfNeeded(target, false)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8078"></a>
v2</h3>
<div class="fragment"><div class="line">import scrollIntoView from &#39;scroll-into-view-if-needed&#39;</div>
<div class="line"> </div>
<div class="line">scrollIntoView(target, { block: &#39;center&#39; })</div>
<div class="line">scrollIntoView(target, { block: &#39;nearest&#39; })</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8079"></a>
duration</h2>
<p>More information.</p>
<h3><a class="anchor" id="autotoc_md8080"></a>
v1</h3>
<div class="fragment"><div class="line">import scrollIntoViewIfNeeded from &#39;scroll-into-view-if-needed&#39;</div>
<div class="line"> </div>
<div class="line">scrollIntoViewIfNeeded(target, { duration: 300 })</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8081"></a>
v2</h3>
<div class="fragment"><div class="line">import scrollIntoView from &#39;scroll-into-view-if-needed&#39;</div>
<div class="line">// or</div>
<div class="line">import scrollIntoView from &#39;smooth-scroll-into-view-if-needed&#39;</div>
<div class="line"> </div>
<div class="line">scrollIntoView(target, { behavior: &#39;smooth&#39; })</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8082"></a>
easing</h2>
<p>This feature is removed, but you can achieve the same thing by implementing `behavior: Function`.</p>
<h2><a class="anchor" id="autotoc_md8083"></a>
handleScroll</h2>
<p>This is replaced with `behavior: Function` with one key difference. Instead of firing once per element that should be scrolled, the new API only fire once and instead give you an array so you can much easier batch and scroll multiple elements at the same time. Or sync scrolling with another element if that's the kind of stuff you're into, I don't judge.</p>
<div class="fragment"><div class="line">-import scrollIntoViewIfNeeded from &#39;scroll-into-view-if-needed&#39;</div>
<div class="line">+import scrollIntoView from &#39;scroll-into-view-if-needed&#39;</div>
<div class="line"> </div>
<div class="line">-scrollIntoViewIfNeeded(node, {handleScroll: (el, {scrollTop, scrollLeft}) =&gt; {</div>
<div class="line">-  el.scrollTop = scrollTop</div>
<div class="line">-  el.scrollLeft = scrollLeft</div>
<div class="line">-}})</div>
<div class="line">+scrollIntoView(node, {behavior: actions.forEach(({el, top, left}) =&gt; {</div>
<div class="line">+  el.scrollTop = top</div>
<div class="line">+  el.scrollLeft = left</div>
<div class="line">+})})</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8084"></a>
offset</h2>
<p>This was always a buggy feature and warned against using in v1 as it might get dropped. It's much safer to use CSS wrapper elements for this kind of thing.</p>
<h2><a class="anchor" id="autotoc_md8085"></a>
scrollIntoViewIfNeeded(target, [centerIfNeeded], [animateOptions], [finalElement], [offsetOptions])</h2>
<p>This API signature were warned to be dropped in <code>v2.0.0</code>, and it was.</p>
<h1><a class="anchor" id="autotoc_md8086"></a>
Related packages</h1>
<ul>
<li><a href="https://www.npmjs.com/package/compute-scroll-into-view">compute-scroll-into-view</a> - the engine used by this library.</li>
<li><a href="https://www.npmjs.com/package/smooth-scroll-into-view-if-needed">smooth-scroll-into-view-if-needed</a> â€“ ponyfills smooth scrolling.</li>
<li><a href="https://www.npmjs.com/package/react-scroll-into-view-if-needed">react-scroll-into-view-if-needed</a> â€“ A thin wrapper to scroll your component into view.</li>
<li><a href="https://www.npmjs.com/package/scroll-polyfill">scroll-polyfill</a> â€“ polyfills smooth scrolling.</li>
<li><a href="https://github.com/scroll-into-view/scroll-into-view-if-needed/edit/main/README.md">Don't be shy, add yours!</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md8087"></a>
Who's using this</h1>
<ul>
<li><a href="https://github.com/zeit/docs">zeit.co/docs</a> â€“ Documentation of ZEIT Now and other services.</li>
<li><a href="https://github.com/SeleniumHQ/selenium-ide">Selenium IDE</a> â€“ An integrated development environment for Selenium scripts.</li>
<li><a href="https://github.com/box/box-ui-elements">Box UI Elements</a> â€“ Box UI Elements are pre-built UI components that allow developers to add elements of the main Box web application into their own applications.</li>
<li><a href="https://github.com/catamphetamine/react-responsive-ui">react-responsive-ui</a> â€“ Responsive React UI components.</li>
<li><a href="https://github.com/mineral-ui/mineral-ui">Mineral UI</a> â€“ A design system and React component library for the web that lets you quickly build high-quality, accessible apps.</li>
<li><a href="https://github.com/Teradata/covalent">Covalent</a> â€“ Teradata UI Platform built on Angular <a class="el" href="class_material.html">Material</a>.</li>
<li><a href="https://github.com/expo/expo-docs">docs.expo.io</a> â€“ Documentation for Expo, its SDK, client and services.</li>
<li><a href="https://github.com/scroll-into-view/scroll-into-view-if-needed/edit/main/README.md">Add yourself to the list ðŸ˜‰</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md8088"></a>
Sponsors</h1>
<p>Thanks to <a href="https://www.browserstack.com">BrowserStack</a> for sponsoring cross browser and device testing ðŸ˜„</p>
<p><a href="https://www.browserstack.com" target="_blank"><img src="https://www.browserstack.com/images/layout/logo.svg" alt="" style="pointer-events: none;" class="inline"/></a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
