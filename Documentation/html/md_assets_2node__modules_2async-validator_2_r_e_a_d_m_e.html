<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DatabaseManager: async-validator</title>
<link rel="icon" href="icon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DatabaseManager<span id="projectnumber">&#160;1.0.5</span>
   </div>
   <div id="projectbrief">Database Manager Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_assets_2node__modules_2async-validator_2_r_e_a_d_m_e.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">async-validator</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md1327"></a> <a href="https://npmjs.org/package/async-validator"><img src="https://img.shields.io/npm/v/async-validator.svg?style=flat-square" alt="NPM version" style="pointer-events: none;" class="inline"/></a> <a href="https://app.travis-ci.com/github/yiminghe/async-validator"><img src="https://app.travis-ci.com/yiminghe/async-validator.svg?branch=master" alt="build status" style="pointer-events: none;" class="inline"/></a> <a href="https://coveralls.io/r/yiminghe/async-validator?branch=master"><img src="https://img.shields.io/coveralls/yiminghe/async-validator.svg?style=flat-square" alt="Test coverage" style="pointer-events: none;" class="inline"/></a> <a href="https://nodejs.org/download/"><img src="https://img.shields.io/badge/node.js-%3E=4.0.0-green.svg?style=flat-square" alt="node version" style="pointer-events: none;" class="inline"/></a> <a href="https://npmjs.org/package/async-validator"><img src="https://img.shields.io/npm/dm/async-validator.svg?style=flat-square" alt="npm download" style="pointer-events: none;" class="inline"/></a> <a href="https://bundlephobia.com/result?p=async-validator"><img src="https://img.shields.io/bundlephobia/minzip/async-validator.svg?label=gzip%20size" alt="npm bundle size (minified + gzip)" style="pointer-events: none;" class="inline"/></a></p>
<p>Validate form asynchronous. A variation of <a href="https://github.com/freeformsystems/async-validate">https://github.com/freeformsystems/async-validate</a></p>
<h1><a class="anchor" id="autotoc_md1328"></a>
Install</h1>
<div class="fragment"><div class="line">npm i async-validator</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1329"></a>
Usage</h1>
<p>Basic usage involves defining a descriptor, assigning it to a schema and passing the object to be validated and a callback function to the <code>validate</code> method of the schema:</p>
<div class="fragment"><div class="line">import Schema from &#39;async-validator&#39;;</div>
<div class="line">const descriptor = {</div>
<div class="line">  name: {</div>
<div class="line">    type: &#39;string&#39;,</div>
<div class="line">    required: true,</div>
<div class="line">    validator: (rule, value) =&gt; value === &#39;muji&#39;,</div>
<div class="line">  },</div>
<div class="line">  age: {</div>
<div class="line">    type: &#39;number&#39;,</div>
<div class="line">    asyncValidator: (rule, value) =&gt; {</div>
<div class="line">      return new Promise((resolve, reject) =&gt; {</div>
<div class="line">        if (value &lt; 18) {</div>
<div class="line">          reject(&#39;too young&#39;);  // reject with error message</div>
<div class="line">        } else {</div>
<div class="line">          resolve();</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">    },</div>
<div class="line">  },</div>
<div class="line">};</div>
<div class="line">const validator = new Schema(descriptor);</div>
<div class="line">validator.validate({ name: &#39;muji&#39; }, (errors, fields) =&gt; {</div>
<div class="line">  if (errors) {</div>
<div class="line">    // validation failed, errors is an array of all errors</div>
<div class="line">    // fields is an object keyed by field name with an array of</div>
<div class="line">    // errors per field</div>
<div class="line">    return handleErrors(errors, fields);</div>
<div class="line">  }</div>
<div class="line">  // validation passed</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// PROMISE USAGE</div>
<div class="line">validator.validate({ name: &#39;muji&#39;, age: 16 }).then(() =&gt; {</div>
<div class="line">  // validation passed or without error message</div>
<div class="line">}).catch(({ errors, fields }) =&gt; {</div>
<div class="line">  return handleErrors(errors, fields);</div>
<div class="line">});</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1330"></a>
API</h1>
<h2><a class="anchor" id="autotoc_md1331"></a>
Validate</h2>
<div class="fragment"><div class="line">function(source, [options], callback): Promise</div>
</div><!-- fragment --><ul>
<li><code>source</code>: The object to validate (required).</li>
<li><code>options</code>: An object describing processing options for the validation (optional).</li>
<li><code>callback</code>: A callback function to invoke when validation completes (optional).</li>
</ul>
<p>The method will return a Promise object like:</p><ul>
<li><code>then()</code>，validation passed</li>
<li><code>catch({ errors, fields })</code>，validation failed, errors is an array of all errors, fields is an object keyed by field name with an array of errors per field</li>
</ul>
<h2><a class="anchor" id="autotoc_md1332"></a>
Options</h2>
<ul>
<li><code>suppressWarning</code>: Boolean, whether to suppress internal warning about invalid value.</li>
<li><code>first</code>: Boolean, Invoke <code>callback</code> when the first validation rule generates an error, no more validation rules are processed. If your validation involves multiple asynchronous calls (for example, database queries) and you only need the first error use this option.</li>
<li><code>firstFields</code>: Boolean|String[], Invoke <code>callback</code> when the first validation rule of the specified field generates an error, no more validation rules of the same field are processed. <code>true</code> means all fields.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1333"></a>
Rules</h2>
<p>Rules may be functions that perform validation.</p>
<div class="fragment"><div class="line">function(rule, value, callback, source, options)</div>
</div><!-- fragment --><ul>
<li><code>rule</code>: The validation rule in the source descriptor that corresponds to the field name being validated. It is always assigned a <code>field</code> property with the name of the field being validated.</li>
<li><code>value</code>: The value of the source object property being validated.</li>
<li><code>callback</code>: A callback function to invoke once validation is complete. It expects to be passed an array of <code>Error</code> instances to indicate validation failure. If the check is synchronous, you can directly return a <code>false</code> or <code>Error</code> or <code>Error Array</code>.</li>
<li><code>source</code>: The source object that was passed to the <code>validate</code> method.</li>
<li><code>options</code>: Additional options.</li>
<li><code>options.messages</code>: The object containing validation error messages, will be deep merged with defaultMessages.</li>
</ul>
<p>The options passed to <code>validate</code> or <code>asyncValidate</code> are passed on to the validation functions so that you may reference transient data (such as model references) in validation functions. However, some option names are reserved; if you use these properties of the options object they are overwritten. The reserved properties are <code>messages</code>, <code>exception</code> and <code>error</code>.</p>
<div class="fragment"><div class="line">import Schema from &#39;async-validator&#39;;</div>
<div class="line">const descriptor = {</div>
<div class="line">  name(rule, value, callback, source, options) {</div>
<div class="line">    const errors = [];</div>
<div class="line">    if (!/^[a-z0-9]+$/.test(value)) {</div>
<div class="line">      errors.push(new Error(</div>
<div class="line">        util.format(&#39;%s must be lowercase alphanumeric characters&#39;, rule.field),</div>
<div class="line">      ));</div>
<div class="line">    }</div>
<div class="line">    return errors;</div>
<div class="line">  },</div>
<div class="line">};</div>
<div class="line">const validator = new Schema(descriptor);</div>
<div class="line">validator.validate({ name: &#39;Firstname&#39; }, (errors, fields) =&gt; {</div>
<div class="line">  if (errors) {</div>
<div class="line">    return handleErrors(errors, fields);</div>
<div class="line">  }</div>
<div class="line">  // validation passed</div>
<div class="line">});</div>
</div><!-- fragment --><p>It is often useful to test against multiple validation rules for a single field, to do so make the rule an array of objects, for example:</p>
<div class="fragment"><div class="line">const descriptor = {</div>
<div class="line">  email: [</div>
<div class="line">    { type: &#39;string&#39;, required: true, pattern: Schema.pattern.email },</div>
<div class="line">    { </div>
<div class="line">      validator(rule, value, callback, source, options) {</div>
<div class="line">        const errors = [];</div>
<div class="line">        // test if email address already exists in a database</div>
<div class="line">        // and add a validation error to the errors array if it does</div>
<div class="line">        return errors;</div>
<div class="line">      },</div>
<div class="line">    },</div>
<div class="line">  ],</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1334"></a>
Type</h3>
<p>Indicates the <code>type</code> of validator to use. Recognised type values are:</p>
<ul>
<li><code>string</code>: Must be of type <code>string</code>. <code>This is the default type.</code></li>
<li><code>number</code>: Must be of type <code>number</code>.</li>
<li><code>boolean</code>: Must be of type <code>boolean</code>.</li>
<li><code>method</code>: Must be of type <code>function</code>.</li>
<li><code>regexp</code>: Must be an instance of <code>RegExp</code> or a string that does not generate an exception when creating a new <code>RegExp</code>.</li>
<li><code>integer</code>: Must be of type <code>number</code> and an integer.</li>
<li><code>float</code>: Must be of type <code>number</code> and a floating point number.</li>
<li><code>array</code>: Must be an array as determined by <code>Array.isArray</code>.</li>
<li><code>object</code>: Must be of type <code>object</code> and not <code>Array.isArray</code>.</li>
<li><code>enum</code>: Value must exist in the <code>enum</code>.</li>
<li><code>date</code>: Value must be valid as determined by <code>Date</code></li>
<li><code>url</code>: Must be of type <code>url</code>.</li>
<li><code>hex</code>: Must be of type <code>hex</code>.</li>
<li><code>email</code>: Must be of type <code>email</code>.</li>
<li><code>any</code>: Can be any type.</li>
</ul>
<h3><a class="anchor" id="autotoc_md1335"></a>
Required</h3>
<p>The <code>required</code> rule property indicates that the field must exist on the source object being validated.</p>
<h3><a class="anchor" id="autotoc_md1336"></a>
Pattern</h3>
<p>The <code>pattern</code> rule property indicates a regular expression that the value must match to pass validation.</p>
<h3><a class="anchor" id="autotoc_md1337"></a>
Range</h3>
<p>A range is defined using the <code>min</code> and <code>max</code> properties. For <code>string</code> and <code>array</code> types comparison is performed against the <code>length</code>, for <code>number</code> types the number must not be less than <code>min</code> nor greater than <code>max</code>.</p>
<h3><a class="anchor" id="autotoc_md1338"></a>
Length</h3>
<p>To validate an exact length of a field specify the <code>len</code> property. For <code>string</code> and <code>array</code> types comparison is performed on the <code>length</code> property, for the <code>number</code> type this property indicates an exact match for the <code>number</code>, ie, it may only be strictly equal to <code>len</code>.</p>
<p>If the <code>len</code> property is combined with the <code>min</code> and <code>max</code> range properties, <code>len</code> takes precedence.</p>
<h3><a class="anchor" id="autotoc_md1339"></a>
Enumerable</h3>
<blockquote class="doxtable">
<p>&zwj;Since version 3.0.0 if you want to validate the values <code>0</code> or <code>false</code> inside <code>enum</code> types, you have to include them explicitly. </p>
</blockquote>
<p>To validate a value from a list of possible values use the <code>enum</code> type with a <code>enum</code> property listing the valid values for the field, for example:</p>
<div class="fragment"><div class="line">const descriptor = {</div>
<div class="line">  role: { type: &#39;enum&#39;, enum: [&#39;admin&#39;, &#39;user&#39;, &#39;guest&#39;] },</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1340"></a>
Whitespace</h3>
<p>It is typical to treat required fields that only contain whitespace as errors. To add an additional test for a string that consists solely of whitespace add a <code>whitespace</code> property to a rule with a value of <code>true</code>. The rule must be a <code>string</code> type.</p>
<p>You may wish to sanitize user input instead of testing for whitespace, see transform for an example that would allow you to strip whitespace.</p>
<h3><a class="anchor" id="autotoc_md1341"></a>
Deep Rules</h3>
<p>If you need to validate deep object properties you may do so for validation rules that are of the <code>object</code> or <code>array</code> type by assigning nested rules to a <code>fields</code> property of the rule.</p>
<div class="fragment"><div class="line">const descriptor = {</div>
<div class="line">  address: {</div>
<div class="line">    type: &#39;object&#39;,</div>
<div class="line">    required: true,</div>
<div class="line">    fields: {</div>
<div class="line">      street: { type: &#39;string&#39;, required: true },</div>
<div class="line">      city: { type: &#39;string&#39;, required: true },</div>
<div class="line">      zip: { type: &#39;string&#39;, required: true, len: 8, message: &#39;invalid zip&#39; },</div>
<div class="line">    },</div>
<div class="line">  },</div>
<div class="line">  name: { type: &#39;string&#39;, required: true },</div>
<div class="line">};</div>
<div class="line">const validator = new Schema(descriptor);</div>
<div class="line">validator.validate({ address: {} }, (errors, fields) =&gt; {</div>
<div class="line">  // errors for address.street, address.city, address.zip</div>
<div class="line">});</div>
</div><!-- fragment --><p>Note that if you do not specify the <code>required</code> property on the parent rule it is perfectly valid for the field not to be declared on the source object and the deep validation rules will not be executed as there is nothing to validate against.</p>
<p>Deep rule validation creates a schema for the nested rules so you can also specify the <code>options</code> passed to the <code>schema.validate()</code> method.</p>
<div class="fragment"><div class="line">const descriptor = {</div>
<div class="line">  address: {</div>
<div class="line">    type: &#39;object&#39;,</div>
<div class="line">    required: true,</div>
<div class="line">    options: { first: true },</div>
<div class="line">    fields: {</div>
<div class="line">      street: { type: &#39;string&#39;, required: true },</div>
<div class="line">      city: { type: &#39;string&#39;, required: true },</div>
<div class="line">      zip: { type: &#39;string&#39;, required: true, len: 8, message: &#39;invalid zip&#39; },</div>
<div class="line">    },</div>
<div class="line">  },</div>
<div class="line">  name: { type: &#39;string&#39;, required: true },</div>
<div class="line">};</div>
<div class="line">const validator = new Schema(descriptor);</div>
<div class="line"> </div>
<div class="line">validator.validate({ address: {} })</div>
<div class="line">  .catch(({ errors, fields }) =&gt; {</div>
<div class="line">    // now only errors for street and name    </div>
<div class="line">  });</div>
</div><!-- fragment --><p>The parent rule is also validated so if you have a set of rules such as:</p>
<div class="fragment"><div class="line">const descriptor = {</div>
<div class="line">  roles: {</div>
<div class="line">    type: &#39;array&#39;,</div>
<div class="line">    required: true,</div>
<div class="line">    len: 3,</div>
<div class="line">    fields: {</div>
<div class="line">      0: { type: &#39;string&#39;, required: true },</div>
<div class="line">      1: { type: &#39;string&#39;, required: true },</div>
<div class="line">      2: { type: &#39;string&#39;, required: true },</div>
<div class="line">    },</div>
<div class="line">  },</div>
<div class="line">};</div>
</div><!-- fragment --><p>And supply a source object of &lsquo;{ roles: ['admin&rsquo;, 'user'] }` then two errors will be created. One for the array length mismatch and one for the missing required array entry at index 2.</p>
<h3><a class="anchor" id="autotoc_md1342"></a>
defaultField</h3>
<p>The <code>defaultField</code> property can be used with the <code>array</code> or <code>object</code> type for validating all values of the container. It may be an <code>object</code> or <code>array</code> containing validation rules. For example:</p>
<div class="fragment"><div class="line">const descriptor = {</div>
<div class="line">  urls: {</div>
<div class="line">    type: &#39;array&#39;,</div>
<div class="line">    required: true,</div>
<div class="line">    defaultField: { type: &#39;url&#39; },</div>
<div class="line">  },</div>
<div class="line">};</div>
</div><!-- fragment --><p>Note that <code>defaultField</code> is expanded to <code>fields</code>, see deep rules.</p>
<h3><a class="anchor" id="autotoc_md1343"></a>
Transform</h3>
<p>Sometimes it is necessary to transform a value before validation, possibly to coerce the value or to sanitize it in some way. To do this add a <code>transform</code> function to the validation rule. The property is transformed prior to validation and returned as promise result or callback result when pass validation.</p>
<div class="fragment"><div class="line">import Schema from &#39;async-validator&#39;;</div>
<div class="line">const descriptor = {</div>
<div class="line">  name: {</div>
<div class="line">    type: &#39;string&#39;,</div>
<div class="line">    required: true,</div>
<div class="line">    pattern: /^[a-z]+$/,</div>
<div class="line">    transform(value) {</div>
<div class="line">      return value.trim();</div>
<div class="line">    },</div>
<div class="line">  },</div>
<div class="line">};</div>
<div class="line">const validator = new Schema(descriptor);</div>
<div class="line">const source = { name: &#39; user  &#39; };</div>
<div class="line"> </div>
<div class="line">validator.validate(source)</div>
<div class="line">  .then((data) =&gt; assert.equal(data.name, &#39;user&#39;));</div>
<div class="line"> </div>
<div class="line">validator.validate(source,(errors, data)=&gt;{</div>
<div class="line">  assert.equal(data.name, &#39;user&#39;));</div>
<div class="line">});</div>
</div><!-- fragment --><p>Without the <code>transform</code> function validation would fail due to the pattern not matching as the input contains leading and trailing whitespace, but by adding the transform function validation passes and the field value is sanitized at the same time.</p>
<h3><a class="anchor" id="autotoc_md1344"></a>
Messages</h3>
<p>Depending upon your application requirements, you may need i18n support or you may prefer different validation error messages.</p>
<p>The easiest way to achieve this is to assign a <code>message</code> to a rule:</p>
<div class="fragment"><div class="line">{ name: { type: &#39;string&#39;, required: true, message: &#39;Name is required&#39; } }</div>
</div><!-- fragment --><p>Message can be any type, such as jsx format.</p>
<div class="fragment"><div class="line">{ name: { type: &#39;string&#39;, required: true, message: &#39;&lt;b&gt;Name is required&lt;/b&gt;&#39; } }</div>
</div><!-- fragment --><p>Message can also be a function, e.g. if you use vue-i18n: </p><div class="fragment"><div class="line">{ name: { type: &#39;string&#39;, required: true, message: () =&gt; this.$t( &#39;name is required&#39; ) } }</div>
</div><!-- fragment --><p>Potentially you may require the same schema validation rules for different languages, in which case duplicating the schema rules for each language does not make sense.</p>
<p>In this scenario you could just provide your own messages for the language and assign it to the schema:</p>
<div class="fragment"><div class="line">import Schema from &#39;async-validator&#39;;</div>
<div class="line">const cn = {</div>
<div class="line">  required: &#39;%s 必填&#39;,</div>
<div class="line">};</div>
<div class="line">const descriptor = { name: { type: &#39;string&#39;, required: true } };</div>
<div class="line">const validator = new Schema(descriptor);</div>
<div class="line">// deep merge with defaultMessages</div>
<div class="line">validator.messages(cn);</div>
<div class="line">...</div>
</div><!-- fragment --><p>If you are defining your own validation functions it is better practice to assign the message strings to a messages object and then access the messages via the <code>options.messages</code> property within the validation function.</p>
<h3><a class="anchor" id="autotoc_md1345"></a>
asyncValidator</h3>
<p>You can customize the asynchronous validation function for the specified field:</p>
<div class="fragment"><div class="line">const fields = {</div>
<div class="line">  asyncField: {</div>
<div class="line">    asyncValidator(rule, value, callback) {</div>
<div class="line">      ajax({</div>
<div class="line">        url: &#39;xx&#39;,</div>
<div class="line">        value: value,</div>
<div class="line">      }).then(function(data) {</div>
<div class="line">        callback();</div>
<div class="line">      }, function(error) {</div>
<div class="line">        callback(new Error(error));</div>
<div class="line">      });</div>
<div class="line">    },</div>
<div class="line">  },</div>
<div class="line"> </div>
<div class="line">  promiseField: {</div>
<div class="line">    asyncValidator(rule, value) {</div>
<div class="line">      return ajax({</div>
<div class="line">        url: &#39;xx&#39;,</div>
<div class="line">        value: value,</div>
<div class="line">      });</div>
<div class="line">    },</div>
<div class="line">  },</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1346"></a>
validator</h3>
<p>You can custom validate function for specified field:</p>
<div class="fragment"><div class="line">const fields = {</div>
<div class="line">  field: {</div>
<div class="line">    validator(rule, value, callback) {</div>
<div class="line">      return value === &#39;test&#39;;</div>
<div class="line">    },</div>
<div class="line">    message: &#39;Value is not equal to &quot;test&quot;.&#39;,</div>
<div class="line">  },</div>
<div class="line"> </div>
<div class="line">  field2: {</div>
<div class="line">    validator(rule, value, callback) {</div>
<div class="line">      return new Error(`${value} is not equal to &#39;test&#39;.`);</div>
<div class="line">    },</div>
<div class="line">  },</div>
<div class="line"> </div>
<div class="line">  arrField: {</div>
<div class="line">    validator(rule, value) {</div>
<div class="line">      return [</div>
<div class="line">        new Error(&#39;Message 1&#39;),</div>
<div class="line">        new Error(&#39;Message 2&#39;),</div>
<div class="line">      ];</div>
<div class="line">    },</div>
<div class="line">  },</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1347"></a>
FAQ</h1>
<h2><a class="anchor" id="autotoc_md1348"></a>
How to avoid global warning</h2>
<div class="fragment"><div class="line">import Schema from &#39;async-validator&#39;;</div>
<div class="line">Schema.warning = function(){};</div>
</div><!-- fragment --><p>or </p><div class="fragment"><div class="line">globalThis.ASYNC_VALIDATOR_NO_WARNING = 1;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1349"></a>
How to check if it is <code>true</code></h2>
<p>Use <code>enum</code> type passing <code>true</code> as option.</p>
<div class="fragment"><div class="line">{</div>
<div class="line">  type: &#39;enum&#39;,</div>
<div class="line">  enum: [true],</div>
<div class="line">  message: &#39;&#39;,</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1350"></a>
Test Case</h1>
<div class="fragment"><div class="line">npm test</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1351"></a>
Coverage</h1>
<div class="fragment"><div class="line">npm run coverage</div>
</div><!-- fragment --><p>Open coverage/ dir</p>
<h1><a class="anchor" id="autotoc_md1352"></a>
License</h1>
<p>Everything is <a href="https://en.wikipedia.org/wiki/MIT_License">MIT</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
