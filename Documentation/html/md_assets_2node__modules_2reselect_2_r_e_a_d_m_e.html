<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DatabaseManager: Reselect</title>
<link rel="icon" href="icon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DatabaseManager<span id="projectnumber">&#160;1.0.5</span>
   </div>
   <div id="projectbrief">Database Manager Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_assets_2node__modules_2reselect_2_r_e_a_d_m_e.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Reselect</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md7851"></a> A library for creating memoized "selector" functions. Commonly used with Redux, but usable with any plain JS immutable data as well.</p>
<ul>
<li>Selectors can compute derived data, allowing Redux to store the minimal possible state.</li>
<li>Selectors are efficient. A selector is not recomputed unless one of its arguments changes.</li>
<li>Selectors are composable. They can be used as input to other selectors.</li>
</ul>
<p>The <b>Redux docs usage page on <a href="https://redux.js.org/usage/deriving-data-selectors">Deriving Data with Selectors</a></b> covers the purpose and motivation for selectors, why memoized selectors are useful, typical Reselect usage patterns, and using selectors with React-Redux.</p>
<p><a href="https://github.com/reduxjs/reselect/actions/workflows/build-and-test-types.yml"><img src="https://img.shields.io/github/workflow/status/reduxjs/redux-thunk/Tests" alt="GitHub Workflow Status" class="inline"/></a> <a href="https://www.npmjs.org/package/reselect"><img src="https://img.shields.io/npm/v/reselect.svg?style=flat-square" alt="npm package" style="pointer-events: none;" class="inline"/></a> <a href="https://coveralls.io/github/reduxjs/reselect"><img src="https://img.shields.io/coveralls/reduxjs/reselect/master.svg?style=flat-square" alt="Coveralls" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md7852"></a>
Installation</h1>
<h2><a class="anchor" id="autotoc_md7853"></a>
Redux Toolkit</h2>
<p>While Reselect is not exclusive to Redux, it is already included by default in <a href="https://redux-toolkit.js.org">the official Redux Toolkit package</a> - no further installation needed.</p>
<div class="fragment"><div class="line">import { createSelector } from &#39;@reduxjs/toolkit&#39;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7854"></a>
Standalone</h2>
<p>For standalone usage, install the <code>reselect</code> package:</p>
<div class="fragment"><div class="line">npm install reselect</div>
<div class="line"> </div>
<div class="line">yarn add reselect</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md7855"></a>
Basic Usage</h1>
<p>Reselect exports a <code>createSelector</code> API, which generates memoized selector functions. <code>createSelector</code> accepts one or more "input" selectors, which extract values from arguments, and an "output" selector that receives the extracted values and should return a derived value. If the generated selector is called multiple times, the output will only be recalculated when the extracted values have changed.</p>
<p>You can play around with the following <b>example</b> in <a href="https://codesandbox.io/s/objective-waterfall-1z5y8?file=/src/index.js">this CodeSandbox</a>:</p>
<div class="fragment"><div class="line">import { createSelector } from &#39;reselect&#39;</div>
<div class="line"> </div>
<div class="line">const selectShopItems = state =&gt; state.shop.items</div>
<div class="line">const selectTaxPercent = state =&gt; state.shop.taxPercent</div>
<div class="line"> </div>
<div class="line">const selectSubtotal = createSelector(selectShopItems, items =&gt;</div>
<div class="line">  items.reduce((subtotal, item) =&gt; subtotal + item.value, 0)</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">const selectTax = createSelector(</div>
<div class="line">  selectSubtotal,</div>
<div class="line">  selectTaxPercent,</div>
<div class="line">  (subtotal, taxPercent) =&gt; subtotal * (taxPercent / 100)</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">const selectTotal = createSelector(</div>
<div class="line">  selectSubtotal,</div>
<div class="line">  selectTax,</div>
<div class="line">  (subtotal, tax) =&gt; ({ total: subtotal + tax })</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">const exampleState = {</div>
<div class="line">  shop: {</div>
<div class="line">    taxPercent: 8,</div>
<div class="line">    items: [</div>
<div class="line">      { name: &#39;apple&#39;, value: 1.2 },</div>
<div class="line">      { name: &#39;orange&#39;, value: 0.95 }</div>
<div class="line">    ]</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">console.log(selectSubtotal(exampleState)) // 2.15</div>
<div class="line">console.log(selectTax(exampleState)) // 0.172</div>
<div class="line">console.log(selectTotal(exampleState)) // { total: 2.322 }</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md7856"></a>
Table of Contents</h1>
<ul>
<li>Installation<ul>
<li>Redux Toolkit</li>
<li>Standalone</li>
</ul>
</li>
<li>Basic Usage</li>
<li>API<ul>
<li>createSelector(...inputSelectors | [inputSelectors], resultFunc, selectorOptions?)</li>
<li>defaultMemoize(func, equalityCheckOrOptions = defaultEqualityCheck)</li>
<li>createSelectorCreator(memoize, ...memoizeOptions)<ul>
<li>Customize `equalityCheck` for `defaultMemoize`</li>
<li>Use memoize function from Lodash for an unbounded cache</li>
</ul>
</li>
<li>createStructuredSelector({inputSelectors}, selectorCreator = createSelector)</li>
</ul>
</li>
<li><a class="el" href="md_assets_2node__modules_2safer-buffer_2_porting-_buffer.html#faq">FAQ</a><ul>
<li>Q: Why isnâ€™t my selector recomputing when the input state changes?</li>
<li>Q: Why is my selector recomputing when the input state stays the same?</li>
<li>Q: Can I use Reselect without Redux?</li>
<li>Q: How do I create a selector that takes an argument?</li>
<li>Q: The default memoization function is no good, can I use a different one?</li>
<li>Q: How do I test a selector?</li>
<li>Q: Can I share a selector across multiple component instances?</li>
<li>Q: Are there TypeScript Typings?</li>
<li>Q: How can I make a curried selector?</li>
</ul>
</li>
<li>Related Projects<ul>
<li>re-reselect</li>
<li>reselect-tools</li>
<li>reselect-debugger</li>
</ul>
</li>
<li>License</li>
<li>Prior Art and Inspiration</li>
</ul>
<h1><a class="anchor" id="autotoc_md7857"></a>
API</h1>
<h2><a class="anchor" id="autotoc_md7858"></a>
createSelector(...inputSelectors | [inputSelectors], resultFunc, selectorOptions?)</h2>
<p>Accepts one or more "input selectors" (either as separate arguments or a single array), a single "output selector" / "result function", and an optional options object, and generates a memoized selector function.</p>
<p>When the selector is called, each input selector will be called with all of the provided arguments. The extracted values are then passed as separate arguments to the output selector, which should calculate and return a final result. The inputs and result are cached for later use.</p>
<p>If the selector is called again with the same arguments, the previously cached result is returned instead of recalculating a new result.</p>
<p><code>createSelector</code> determines if the value returned by an input-selector has changed between calls using reference equality (<code>===</code>). Inputs to selectors created with <code>createSelector</code> should be immutable.</p>
<p>By default, selectors created with <code>createSelector</code> have a cache size of 1. This means they always recalculate when the value of an input-selector changes, as a selector only stores the preceding value of each input-selector. This can be customized by passing a <code>selectorOptions</code> object with a <code>memoizeOptions</code> field containing options for the built-in <code>defaultMemoize</code> memoization function .</p>
<div class="fragment"><div class="line">const selectValue = createSelector(</div>
<div class="line">  state =&gt; state.values.value1,</div>
<div class="line">  state =&gt; state.values.value2,</div>
<div class="line">  (value1, value2) =&gt; value1 + value2</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">// You can also pass an array of selectors</div>
<div class="line">const selectTotal = createSelector(</div>
<div class="line">  [state =&gt; state.values.value1, state =&gt; state.values.value2],</div>
<div class="line">  (value1, value2) =&gt; value1 + value2</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">// Selector behavior can be customized</div>
<div class="line">const customizedSelector = createSelector(</div>
<div class="line">  state =&gt; state.a,</div>
<div class="line">  state =&gt; state.b,</div>
<div class="line">  (a, b) =&gt; a + b,</div>
<div class="line">  {</div>
<div class="line">    // New in 4.1: Pass options through to the built-in `defaultMemoize` function</div>
<div class="line">    memoizeOptions: {</div>
<div class="line">      equalityCheck: (a, b) =&gt; a === b,</div>
<div class="line">      maxSize: 10,</div>
<div class="line">      resultEqualityCheck: shallowEqual</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">)</div>
</div><!-- fragment --><p>Selectors are typically called with a Redux <code>state</code> value as the first argument, and the input selectors extract pieces of the <code>state</code> object for use in calculations. However, it's also common to want to pass additional arguments, such as a value to filter by. Since input selectors are given all arguments, they can extract the additional arguments and pass them to the output selector:</p>
<div class="fragment"><div class="line">const selectItemsByCategory = createSelector(</div>
<div class="line">  [</div>
<div class="line">    // Usual first input - extract value from `state`</div>
<div class="line">    state =&gt; state.items,</div>
<div class="line">    // Take the second arg, `category`, and forward to the output selector</div>
<div class="line">    (state, category) =&gt; category</div>
<div class="line">  ],</div>
<div class="line">  // Output selector gets (`items, category)` as args</div>
<div class="line">  (items, category) =&gt; items.filter(item =&gt; item.category === category)</div>
<div class="line">)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7859"></a>
defaultMemoize(func, equalityCheckOrOptions = defaultEqualityCheck)</h2>
<p><code>defaultMemoize</code> memoizes the function passed in the func parameter. It is the standard memoize function used by <code>createSelector</code>.</p>
<p><code>defaultMemoize</code> has a default cache size of 1. This means it always recalculates when the value of an argument changes. However, this can be customized as needed with a specific max cache size (new in 4.1).</p>
<p><code>defaultMemoize</code> determines if an argument has changed by calling the <code>equalityCheck</code> function. As <code>defaultMemoize</code> is designed to be used with immutable data, the default <code>equalityCheck</code> function checks for changes using reference equality:</p>
<div class="fragment"><div class="line">function defaultEqualityCheck(previousVal, currentVal) {</div>
<div class="line">  return currentVal === previousVal</div>
<div class="line">}</div>
</div><!-- fragment --><p>As of Reselect 4.1, <code>defaultMemoize</code> also accepts an options object as its first argument instead of <code>equalityCheck</code>. The options object may contain:</p>
<div class="fragment"><div class="line">interface DefaultMemoizeOptions {</div>
<div class="line">  equalityCheck?: EqualityFn</div>
<div class="line">  resultEqualityCheck?: EqualityFn</div>
<div class="line">  maxSize?: number</div>
<div class="line">}</div>
</div><!-- fragment --><p>Available options are:</p>
<ul>
<li><code>equalityCheck</code>: used to compare the individual arguments of the provided calculation function</li>
<li><code>resultEqualityCheck</code>: if provided, used to compare a newly generated output value against previous values in the cache. If a match is found, the old value is returned. This address the common <code>todos.map(todo =&gt; todo.id)</code> use case, where an update to another field in the original data causes a recalculate due to changed references, but the output is still effectively the same.</li>
<li><code>maxSize</code>: the cache size for the selector. If <code>maxSize</code> is greater than 1, the selector will use an LRU cache internally</li>
</ul>
<p>The returned memoized function will have a <code>.clearCache()</code> method attached.</p>
<p><code>defaultMemoize</code> can also be used with <code>createSelectorCreator</code> to create a new selector factory that always has the same settings for each selector.</p>
<h2><a class="anchor" id="autotoc_md7860"></a>
createSelectorCreator(memoize, ...memoizeOptions)</h2>
<p><code>createSelectorCreator</code> can be used to make a customized version of <code>createSelector</code>.</p>
<p>The <code>memoize</code> argument is a memoization function to replace <code>defaultMemoize</code>.</p>
<p>The <code>...memoizeOptions</code> rest parameters are zero or more configuration options to be passed to <code>memoizeFunc</code>. The selectors <code>resultFunc</code> is passed as the first argument to <code>memoize</code> and the <code>memoizeOptions</code> are passed as the second argument onwards:</p>
<div class="fragment"><div class="line">const customSelectorCreator = createSelectorCreator(</div>
<div class="line">  customMemoize, // function to be used to memoize resultFunc</div>
<div class="line">  option1, // option1 will be passed as second argument to customMemoize</div>
<div class="line">  option2, // option2 will be passed as third argument to customMemoize</div>
<div class="line">  option3 // option3 will be passed as fourth argument to customMemoize</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">const customSelector = customSelectorCreator(</div>
<div class="line">  input1,</div>
<div class="line">  input2,</div>
<div class="line">  resultFunc // resultFunc will be passed as first argument to customMemoize</div>
<div class="line">)</div>
</div><!-- fragment --><p>Internally <code>customSelector</code> calls the memoize function as follows:</p>
<div class="fragment"><div class="line">customMemoize(resultFunc, option1, option2, option3)</div>
</div><!-- fragment --><p>Here are some examples of how you might use <code>createSelectorCreator</code>:</p>
<h3><a class="anchor" id="autotoc_md7861"></a>
Customize <code>equalityCheck</code> for <code>defaultMemoize</code></h3>
<div class="fragment"><div class="line">import { createSelectorCreator, defaultMemoize } from &#39;reselect&#39;</div>
<div class="line">import isEqual from &#39;lodash.isequal&#39;</div>
<div class="line"> </div>
<div class="line">// create a &quot;selector creator&quot; that uses lodash.isequal instead of ===</div>
<div class="line">const createDeepEqualSelector = createSelectorCreator(defaultMemoize, isEqual)</div>
<div class="line"> </div>
<div class="line">// use the new &quot;selector creator&quot; to create a selector</div>
<div class="line">const selectSum = createDeepEqualSelector(</div>
<div class="line">  state =&gt; state.values.filter(val =&gt; val &lt; 5),</div>
<div class="line">  values =&gt; values.reduce((acc, val) =&gt; acc + val, 0)</div>
<div class="line">)</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md7862"></a>
Use memoize function from Lodash for an unbounded cache</h3>
<div class="fragment"><div class="line">import { createSelectorCreator } from &#39;reselect&#39;</div>
<div class="line">import memoize from &#39;lodash.memoize&#39;</div>
<div class="line"> </div>
<div class="line">let called = 0</div>
<div class="line">const hashFn = (...args) =&gt;</div>
<div class="line">  args.reduce((acc, val) =&gt; acc + &#39;-&#39; + JSON.stringify(val), &#39;&#39;)</div>
<div class="line">const customSelectorCreator = createSelectorCreator(memoize, hashFn)</div>
<div class="line">const selector = customSelectorCreator(</div>
<div class="line">  state =&gt; state.a,</div>
<div class="line">  state =&gt; state.b,</div>
<div class="line">  (a, b) =&gt; {</div>
<div class="line">    called++</div>
<div class="line">    return a + b</div>
<div class="line">  }</div>
<div class="line">)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7863"></a>
createStructuredSelector({inputSelectors}, selectorCreator = createSelector)</h2>
<p><code>createStructuredSelector</code> is a convenience function for a common pattern that arises when using Reselect. The selector passed to a <code>connect</code> decorator often just takes the values of its input-selectors and maps them to keys in an object:</p>
<div class="fragment"><div class="line">const selectA = state =&gt; state.a</div>
<div class="line">const selectB = state =&gt; state.b</div>
<div class="line"> </div>
<div class="line">// The result function in the following selector</div>
<div class="line">// is simply building an object from the input selectors</div>
<div class="line">const structuredSelector = createSelector(selectA, selectB, (a, b) =&gt; ({</div>
<div class="line">  a,</div>
<div class="line">  b</div>
<div class="line">}))</div>
</div><!-- fragment --><p><code>createStructuredSelector</code> takes an object whose properties are input-selectors and returns a structured selector. The structured selector returns an object with the same keys as the <code>inputSelectors</code> argument, but with the selectors replaced with their values.</p>
<div class="fragment"><div class="line">const selectA = state =&gt; state.a</div>
<div class="line">const selectB = state =&gt; state.b</div>
<div class="line"> </div>
<div class="line">const structuredSelector = createStructuredSelector({</div>
<div class="line">  x: selectA,</div>
<div class="line">  y: selectB</div>
<div class="line">})</div>
<div class="line"> </div>
<div class="line">const result = structuredSelector({ a: 1, b: 2 }) // will produce { x: 1, y: 2 }</div>
</div><!-- fragment --><p>Structured selectors can be nested:</p>
<div class="fragment"><div class="line">const nestedSelector = createStructuredSelector({</div>
<div class="line">  subA: createStructuredSelector({</div>
<div class="line">    selectorA,</div>
<div class="line">    selectorB</div>
<div class="line">  }),</div>
<div class="line">  subB: createStructuredSelector({</div>
<div class="line">    selectorC,</div>
<div class="line">    selectorD</div>
<div class="line">  })</div>
<div class="line">})</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md7864"></a>
FAQ</h1>
<h2><a class="anchor" id="autotoc_md7865"></a>
Q: Why isnâ€™t my selector recomputing when the input state changes?</h2>
<p>A: Check that your memoization function is compatible with your state update function (i.e. the reducer if you are using Redux). For example, a selector created with <code>createSelector</code> will not work with a state update function that mutates an existing object instead of creating a new one each time. <code>createSelector</code> uses an identity check (<code>===</code>) to detect that an input has changed, so mutating an existing object will not trigger the selector to recompute because mutating an object does not change its identity. Note that if you are using Redux, mutating the state object is <a href="http://redux.js.org/docs/Troubleshooting.html">almost certainly a mistake</a>.</p>
<p>The following example defines a simple selector that determines if the first todo item in an array of todos has been completed:</p>
<div class="fragment"><div class="line">const selectIsFirstTodoComplete = createSelector(</div>
<div class="line">  state =&gt; state.todos[0],</div>
<div class="line">  todo =&gt; todo &amp;&amp; todo.completed</div>
<div class="line">)</div>
</div><!-- fragment --><p>The following state update function <b>will not</b> work with <code>selectIsFirstTodoComplete</code>:</p>
<div class="fragment"><div class="line">export default function todos(state = initialState, action) {</div>
<div class="line">  switch (action.type) {</div>
<div class="line">    case COMPLETE_ALL:</div>
<div class="line">      const areAllMarked = state.every(todo =&gt; todo.completed)</div>
<div class="line">      // BAD: mutating an existing object</div>
<div class="line">      return state.map(todo =&gt; {</div>
<div class="line">        todo.completed = !areAllMarked</div>
<div class="line">        return todo</div>
<div class="line">      })</div>
<div class="line"> </div>
<div class="line">    default:</div>
<div class="line">      return state</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following state update function <b>will</b> work with <code>selectIsFirstTodoComplete</code>:</p>
<div class="fragment"><div class="line">export default function todos(state = initialState, action) {</div>
<div class="line">  switch (action.type) {</div>
<div class="line">    case COMPLETE_ALL:</div>
<div class="line">      const areAllMarked = state.every(todo =&gt; todo.completed)</div>
<div class="line">      // GOOD: returning a new object each time with Object.assign</div>
<div class="line">      return state.map(todo =&gt;</div>
<div class="line">        Object.assign({}, todo, {</div>
<div class="line">          completed: !areAllMarked</div>
<div class="line">        })</div>
<div class="line">      )</div>
<div class="line"> </div>
<div class="line">    default:</div>
<div class="line">      return state</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you are not using Redux and have a requirement to work with mutable data, you can use <code>createSelectorCreator</code> to replace the default memoization function and/or use a different equality check function. See here and here for examples.</p>
<h2><a class="anchor" id="autotoc_md7866"></a>
Q: Why is my selector recomputing when the input state stays the same?</h2>
<p>A: Check that your memoization function is compatible with your state update function (i.e. the reducer if you are using Redux). For example, a selector created with <code>createSelector</code> that recomputes unexpectedly may be receiving a new object on each update whether the values it contains have changed or not. <code>createSelector</code> uses an identity check (<code>===</code>) to detect that an input has changed, so returning a new object on each update means that the selector will recompute on each update.</p>
<div class="fragment"><div class="line">import { REMOVE_OLD } from &#39;../constants/ActionTypes&#39;</div>
<div class="line"> </div>
<div class="line">const initialState = [</div>
<div class="line">  {</div>
<div class="line">    text: &#39;Use Redux&#39;,</div>
<div class="line">    completed: false,</div>
<div class="line">    id: 0,</div>
<div class="line">    timestamp: Date.now()</div>
<div class="line">  }</div>
<div class="line">]</div>
<div class="line"> </div>
<div class="line">export default function todos(state = initialState, action) {</div>
<div class="line">  switch (action.type) {</div>
<div class="line">    case REMOVE_OLD:</div>
<div class="line">      return state.filter(todo =&gt; {</div>
<div class="line">        return todo.timestamp + 30 * 24 * 60 * 60 * 1000 &gt; Date.now()</div>
<div class="line">      })</div>
<div class="line">    default:</div>
<div class="line">      return state</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The following selector is going to recompute every time REMOVE_OLD is invoked because Array.filter always returns a new object. However, in the majority of cases the REMOVE_OLD action will not change the list of todos so the recomputation is unnecessary.</p>
<div class="fragment"><div class="line">import { createSelector } from &#39;reselect&#39;</div>
<div class="line"> </div>
<div class="line">const todosSelector = state =&gt; state.todos</div>
<div class="line"> </div>
<div class="line">export const selectVisibleTodos = createSelector(</div>
<div class="line">  todosSelector,</div>
<div class="line">  (todos) =&gt; {</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">)</div>
</div><!-- fragment --><p>You can eliminate unnecessary recomputations by returning a new object from the state update function only when a deep equality check has found that the list of todos has actually changed:</p>
<div class="fragment"><div class="line">import { REMOVE_OLD } from &#39;../constants/ActionTypes&#39;</div>
<div class="line">import isEqual from &#39;lodash.isequal&#39;</div>
<div class="line"> </div>
<div class="line">const initialState = [</div>
<div class="line">  {</div>
<div class="line">    text: &#39;Use Redux&#39;,</div>
<div class="line">    completed: false,</div>
<div class="line">    id: 0,</div>
<div class="line">    timestamp: Date.now()</div>
<div class="line">  }</div>
<div class="line">]</div>
<div class="line"> </div>
<div class="line">export default function todos(state = initialState, action) {</div>
<div class="line">  switch (action.type) {</div>
<div class="line">    case REMOVE_OLD:</div>
<div class="line">      const updatedState = state.filter(todo =&gt; {</div>
<div class="line">        return todo.timestamp + 30 * 24 * 60 * 60 * 1000 &gt; Date.now()</div>
<div class="line">      })</div>
<div class="line">      return isEqual(updatedState, state) ? state : updatedState</div>
<div class="line">    default:</div>
<div class="line">      return state</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Alternatively, the default <code>equalityCheck</code> function in the selector can be replaced by a deep equality check:</p>
<div class="fragment"><div class="line">import { createSelectorCreator, defaultMemoize } from &#39;reselect&#39;</div>
<div class="line">import isEqual from &#39;lodash.isequal&#39;</div>
<div class="line"> </div>
<div class="line">const selectTodos = state =&gt; state.todos</div>
<div class="line"> </div>
<div class="line">// create a &quot;selector creator&quot; that uses lodash.isequal instead of ===</div>
<div class="line">const createDeepEqualSelector = createSelectorCreator(</div>
<div class="line">  defaultMemoize,</div>
<div class="line">  isEqual</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">// use the new &quot;selector creator&quot; to create a selector</div>
<div class="line">const mySelector = createDeepEqualSelector(</div>
<div class="line">  todosSelector,</div>
<div class="line">  (todos) =&gt; {</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">)</div>
</div><!-- fragment --><p>Always check that the cost of an alternative <code>equalityCheck</code> function or deep equality check in the state update function is not greater than the cost of recomputing every time. If recomputing every time does work out to be the cheaper option, it may be that for this case Reselect is not giving you any benefit over passing a plain <code>mapStateToProps</code> function to <code>connect</code>.</p>
<h2><a class="anchor" id="autotoc_md7867"></a>
Q: Can I use Reselect without Redux?</h2>
<p>A: Yes. Reselect has no dependencies on any other package, so although it was designed to be used with Redux it can be used independently. It can be used with any plain JS data, such as typical React state values, as long as that data is being updated immutably.</p>
<h2><a class="anchor" id="autotoc_md7868"></a>
Q: How do I create a selector that takes an argument?</h2>
<p>As shown in the API reference section above, provide input selectors that extract the arguments and forward them to the output selector for calculation:</p>
<div class="fragment"><div class="line">const selectItemsByCategory = createSelector(</div>
<div class="line">  [</div>
<div class="line">    // Usual first input - extract value from `state`</div>
<div class="line">    state =&gt; state.items,</div>
<div class="line">    // Take the second arg, `category`, and forward to the output selector</div>
<div class="line">    (state, category) =&gt; category</div>
<div class="line">  ],</div>
<div class="line">  // Output selector gets (`items, category)` as args</div>
<div class="line">  (items, category) =&gt; items.filter(item =&gt; item.category === category)</div>
<div class="line">)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7869"></a>
Q: The default memoization function is no good, can I use a different one?</h2>
<p>A: We think it works great for a lot of use cases, but sure. See these examples.</p>
<h2><a class="anchor" id="autotoc_md7870"></a>
Q: How do I test a selector?</h2>
<p>A: For a given input, a selector should always produce the same output. For this reason they are simple to unit test.</p>
<div class="fragment"><div class="line">const selector = createSelector(</div>
<div class="line">  state =&gt; state.a,</div>
<div class="line">  state =&gt; state.b,</div>
<div class="line">  (a, b) =&gt; ({</div>
<div class="line">    c: a * 2,</div>
<div class="line">    d: b * 3</div>
<div class="line">  })</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">test(&#39;selector unit test&#39;, () =&gt; {</div>
<div class="line">  assert.deepEqual(selector({ a: 1, b: 2 }), { c: 2, d: 6 })</div>
<div class="line">  assert.deepEqual(selector({ a: 2, b: 3 }), { c: 4, d: 9 })</div>
<div class="line">})</div>
</div><!-- fragment --><p>It may also be useful to check that the memoization function for a selector works correctly with the state update function (i.e. the reducer if you are using Redux). Each selector has a <code>recomputations</code> method that will return the number of times it has been recomputed:</p>
<div class="fragment"><div class="line">suite(&#39;selector&#39;, () =&gt; {</div>
<div class="line">  let state = { a: 1, b: 2 }</div>
<div class="line"> </div>
<div class="line">  const reducer = (state, action) =&gt; ({</div>
<div class="line">    a: action(state.a),</div>
<div class="line">    b: action(state.b)</div>
<div class="line">  })</div>
<div class="line"> </div>
<div class="line">  const selector = createSelector(</div>
<div class="line">    state =&gt; state.a,</div>
<div class="line">    state =&gt; state.b,</div>
<div class="line">    (a, b) =&gt; ({</div>
<div class="line">      c: a * 2,</div>
<div class="line">      d: b * 3</div>
<div class="line">    })</div>
<div class="line">  )</div>
<div class="line"> </div>
<div class="line">  const plusOne = x =&gt; x + 1</div>
<div class="line">  const id = x =&gt; x</div>
<div class="line"> </div>
<div class="line">  test(&#39;selector unit test&#39;, () =&gt; {</div>
<div class="line">    state = reducer(state, plusOne)</div>
<div class="line">    assert.deepEqual(selector(state), { c: 4, d: 9 })</div>
<div class="line">    state = reducer(state, id)</div>
<div class="line">    assert.deepEqual(selector(state), { c: 4, d: 9 })</div>
<div class="line">    assert.equal(selector.recomputations(), 1)</div>
<div class="line">    state = reducer(state, plusOne)</div>
<div class="line">    assert.deepEqual(selector(state), { c: 6, d: 12 })</div>
<div class="line">    assert.equal(selector.recomputations(), 2)</div>
<div class="line">  })</div>
<div class="line">})</div>
</div><!-- fragment --><p>Additionally, selectors keep a reference to the last result function as <code>.resultFunc</code>. If you have selectors composed of many other selectors this can help you test each selector without coupling all of your tests to the shape of your state.</p>
<p>For example if you have a set of selectors like this:</p>
<p><b>selectors.js</b></p>
<div class="fragment"><div class="line">export const selectFirst = createSelector( ... )</div>
<div class="line">export const selectSecond = createSelector( ... )</div>
<div class="line">export const selectThird = createSelector( ... )</div>
<div class="line"> </div>
<div class="line">export const myComposedSelector = createSelector(</div>
<div class="line">  selectFirst,</div>
<div class="line">  selectSecond,</div>
<div class="line">  selectThird,</div>
<div class="line">  (first, second, third) =&gt; first * second &lt; third</div>
<div class="line">)</div>
</div><!-- fragment --><p>And then a set of unit tests like this:</p>
<p><b>test/selectors.js</b></p>
<div class="fragment"><div class="line">// tests for the first three selectors...</div>
<div class="line">test(&quot;selectFirst unit test&quot;, () =&gt; { ... })</div>
<div class="line">test(&quot;selectSecond unit test&quot;, () =&gt; { ... })</div>
<div class="line">test(&quot;selectThird unit test&quot;, () =&gt; { ... })</div>
<div class="line"> </div>
<div class="line">// We have already tested the previous</div>
<div class="line">// three selector outputs so we can just call `.resultFunc`</div>
<div class="line">// with the values we want to test directly:</div>
<div class="line">test(&quot;myComposedSelector unit test&quot;, () =&gt; {</div>
<div class="line">  // here instead of calling selector()</div>
<div class="line">  // we just call selector.resultFunc()</div>
<div class="line">  assert(myComposedSelector.resultFunc(1, 2, 3), true)</div>
<div class="line">  assert(myComposedSelector.resultFunc(2, 2, 1), false)</div>
<div class="line">})</div>
</div><!-- fragment --><p>Finally, each selector has a <code>resetRecomputations</code> method that sets recomputations back to 0. The intended use is for a complex selector that may have many independent tests and you don't want to manually manage the computation count or create a "dummy" selector for each test.</p>
<h2><a class="anchor" id="autotoc_md7871"></a>
Q: Can I share a selector across multiple component instances?</h2>
<p>A: Yes, although it requires some planning.</p>
<p>As of Reselect 4.1, you can create a selector with a cache size greater than one by passing in a <code>maxSize</code> option under <code>memoizeOptions</code> for use with the built-in <code>defaultMemoize</code>.</p>
<p>Otherwise, selectors created using <code>createSelector</code> only have a cache size of one. This can make them unsuitable for sharing across multiple instances if the arguments to the selector are different for each instance of the component. There are a couple of ways to get around this:</p>
<ul>
<li>Create a factory function which returns a new selector for each instance of the component. This can be called in a React component inside the <code>useMemo</code> hook to generate a unique selector instance per component.</li>
<li>Create a custom selector with a cache size greater than one using <code>createSelectorCreator</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md7872"></a>
Q: Are there TypeScript Typings?</h2>
<p>A: Yes! Reselect is now written in TS itself, so they should Just Workâ„¢.</p>
<h2><a class="anchor" id="autotoc_md7873"></a>
Q: I am seeing a TypeScript error: <code>Type instantiation is excessively deep and possibly infinite</code></h2>
<p>A: This can often occur with deeply recursive types, which occur in this library. Please see <a href="https://github.com/reduxjs/reselect/issues/534#issuecomment-956708953">this comment</a> for a discussion of the problem, as relating to nested selectors.</p>
<h2><a class="anchor" id="autotoc_md7874"></a>
Q: How can I make a <a href="https://github.com/hemanth/functional-programming-jargon#currying">curried</a> selector?</h2>
<p>A: Try these <a href="https://github.com/reduxjs/reselect/issues/159#issuecomment-238724788">helper functions</a> courtesy of <a href="https://github.com/MattSPalmer">MattSPalmer</a></p>
<h1><a class="anchor" id="autotoc_md7875"></a>
Related Projects</h1>
<h2><a class="anchor" id="autotoc_md7876"></a>
<a href="https://github.com/toomuchdesign/re-reselect">re-reselect</a></h2>
<p>Enhances Reselect selectors by wrapping <code>createSelector</code> and returning a memoized collection of selectors indexed with the cache key returned by a custom resolver function.</p>
<p>Useful to reduce selectors recalculation when the same selector is repeatedly called with one/few different arguments.</p>
<h2><a class="anchor" id="autotoc_md7877"></a>
<a href="https://github.com/skortchmark9/reselect-tools">reselect-tools</a></h2>
<p><a href="https://chrome.google.com/webstore/detail/reselect-devtools/cjmaipngmabglflfeepmdiffcijhjlbb?hl=en">Chrome extension</a> and <a href="https://github.com/skortchmark9/reselect-tools">companion lib</a> for debugging selectors.</p>
<ul>
<li>Measure selector recomputations across the app and identify performance bottlenecks</li>
<li>Check selector dependencies, inputs, outputs, and recomputations at any time with the chrome extension</li>
<li>Statically export a JSON representation of your selector graph for further analysis</li>
</ul>
<h2><a class="anchor" id="autotoc_md7878"></a>
<a href="https://github.com/vlanemcev/reselect-debugger-flipper">reselect-debugger</a></h2>
<p><a href="https://github.com/vlanemcev/flipper-plugin-reselect-debugger">Flipper plugin</a> and <a href="https://github.com/vlanemcev/reselect-debugger-flipper">and the connect app</a> for debugging selectors in <b>React Native Apps</b>.</p>
<p>Inspired by Reselect Tools, so it also has all functionality from this library and more, but only for React Native and Flipper.</p>
<ul>
<li>Selectors Recomputations count in live time across the App for identify performance bottlenecks</li>
<li>Highlight most recomputed selectors</li>
<li>Dependency Graph</li>
<li>Search by Selectors Graph</li>
<li>Selectors Inputs</li>
<li>Selectors Output (In case if selector not dependent from external arguments)</li>
<li>Shows "Not Memoized (NM)" selectors</li>
</ul>
<h1><a class="anchor" id="autotoc_md7879"></a>
License</h1>
<p>MIT</p>
<h1><a class="anchor" id="autotoc_md7880"></a>
Prior Art and Inspiration</h1>
<p>Originally inspired by getters in <a href="https://github.com/optimizely/nuclear-js.git">NuclearJS</a>, <a href="https://github.com/Day8/re-frame#just-a-read-only-cursor">subscriptions</a> in <a href="https://github.com/Day8/re-frame">re-frame</a> and this <a href="https://github.com/reduxjs/redux/pull/169">proposal</a> from <a href="https://github.com/speedskater">speedskater</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
